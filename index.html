<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galactic Encounter</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

    body {
      font-family: 'Orbitron', sans-serif;
      background: radial-gradient(circle, #0f0c29, #302b63, #24243e);
      color: #00eaff;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
      position: relative;
      z-index: 0;
    }
   /* heart container */
   /* Heart container */
.heart {
  position: absolute;
  width: 90px;
  height: 90px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2em;
  font-weight: bold;
  color: white; /* Make text inside heart visible */
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  
  border-radius: 50%;
  box-shadow: 0 0 15px rgba(158, 154, 154, 0.9);
  animation: heartbeat 1.2s infinite;
}

/* Heartbeat animation */
@keyframes heartbeat {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.2); }
}

/* Left and right positioning */
.heart-left {
    background: radial-gradient(circle, #ff1414, #ffc669);
  left: 4%;
  top: 10%;
  transform: translateY(-50%);
}

.heart-right {
    background: radial-gradient(circle, #14fff3, #7369ff);
  right: 5%;
  top: 70%;
  transform: translateY(-50%);
}

    /* Container for floating hearts */
    .spaceship-container {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: -1;
    }

    /* Floating hearts animation (drifting) */
    .spaceship-star {
      position: absolute;
      font-size: 1.5em;
      opacity: 1;
      animation: fly 4s linear forwards;
    }
    @keyframes fly {
      0% { transform: translate(0, 0); opacity: 1; }
      100% { transform: translate(var(--dx), var(--dy)); opacity: 0; }
    }

    /* Glowing orbs / planets */
    .orb {
      position: absolute;
      border-radius: 50%;
      animation: pulse 3s infinite alternate;
      z-index: -2;
      background-size: cover;
      background-position: center;
      /* Enhanced glow */
      box-shadow: 0 0 15px rgba(0, 238, 255, 0.7);
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.9; }
      100% { transform: scale(1.1); opacity: 1; }
    }
    /* Regular planets with radial gradients */
    .orb.orb1 {
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, #1e90ff, #00008b);
      top: 10%;
      left: 10%;
    }
    .orb.orb2 {
      width: 80px;
      height: 80px;
      background: radial-gradient(circle, #ff4500, #8b0000);
      bottom: 07%;
      right: 15%;
    }
    .orb.orb3 {
      width: 50px;
      height: 50px;
      background: radial-gradient(circle, #32cd32, #006400);
      top: 20%;
      right: 10%;
    }
    /* Saturn-like planet with a front-view horizontal ring */
    .orb.orb-saturn {
      width: 70px;
      height: 70px;
      background: radial-gradient(circle, #ffcc00, #cc9900);
      bottom: 15%;
      left: 20%;
    }
    .orb.orb-saturn .ring {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 100%;
      height: 20%;
      background: rgba(255, 255, 255, 0.8);
      transform: translate(-50%, -50%);
      border-radius: 10px;
      animation: rotateRing 4s linear infinite;
    }
    @keyframes rotateRing {
      from { transform: translate(-50%, -50%) rotate(0deg); }
      to { transform: translate(-50%, -50%) rotate(360deg); }
    }
    /* Two special orbs on opposite sides with initials */
    .orb.orb-left, .orb.orb-right {
      width: 70px;
      height: 70px;
   
      
      font-size: 2em;
      font-weight: bold;
      color: #ffffff;
      box-shadow: 0 0 25px rgba(255, 255, 255, 0.9);
    }
    .orb.orb-left {
      background: radial-gradient(circle, #ff7f50, #ff4500);
      left: 5%;
      top: 0%;
      transform: translateY(-50%);
    }
    .orb.orb-right {
      background: radial-gradient(circle, #7fffd4, #40e0d0);
      right: 5%;
      top: 50%;
      transform: translateY(-50%);
    }
    .orb.orb-left::after {
      content: 'U';
    }
    .orb.orb-right::after {
      content: 'K';
    }

    /* Main content styling */
    .question-section {
      text-align: center;
      background: rgba(0, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0px 4px 8px rgba(0, 255, 255, 0.3);
      position: relative;
      z-index: 10;
    }
    h2 {
      font-size: 2em;
      color: #00eaff;
      margin: 0 0 10px 0;
    }
    p {
      font-size: 1em;
      color: #00eaff;
      margin: 5px 0 15px 0;
    }
    form label {
      display: block;
      margin: 10px 0;
      font-size: 1.2em;
      cursor: pointer;
    }
    /* Hide input container by default */
    #input-container {
      display: none;
      margin-top: 10px;
    }
    input[type="text"] {
      padding: 8px;
      font-size: 1em;
      background: #111;
      border: 1px solid cyan;
      color: cyan;
      border-radius: 5px;
      width: 80%;
      max-width: 300px;
    }
    button {
      padding: 12px 24px;
      font-size: 1.3em;
      color: black;
      background-color: cyan;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.3s ease, background 0.3s;
      margin-top: 15px;
    }
    button:hover {
      transform: scale(1.1);
      background: #00aaff;
    }

    /* Floating romantic hearts */
    .romantic-hearts {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }
    .romantic-hearts span {
      position: absolute;
      font-size: 1.5em;
      color: #ff69b4;
      opacity: 0.8;
      animation: heartFloat 5s linear infinite;
    }
    @keyframes heartFloat {
      0% { transform: translateY(100vh) scale(0.5); opacity: 0; }
      50% { opacity: 1; }
      100% { transform: translateY(-20vh) scale(1); opacity: 0; }
    }

    /* Transmission star */
    .transmission-star {
      position: absolute;
      font-size: 2em;
      color: #ffff00;
      text-shadow: 0 0 10px #ffff00;
      z-index: 100;
    }
    /* Dotted, glowing trail dots with color cycling */
    .trail-dot {
      position: absolute;
      width: 5px; /* Slightly smaller dots */
      height: 5px;
      border-radius: 50%;
      background: #00ffff; /* Start with cyan */
      animation: enhancedColorCycle 1.5s linear infinite; /* Slightly slower cycle and new animation name */
      filter: drop-shadow(0 0 8px #00ffff); /* Stronger, softer glow */
      opacity: 0.9; /* Slightly reduce opacity for a softer look */
    }
    @keyframes enhancedColorCycle {
      0% { background: #00ffff; filter: drop-shadow(0 0 8px #00ffff); } /* Cyan */
      33% { background: #100876; filter: drop-shadow(0 0 8px #ccffff); } /* Light Cyan */
      66% { background: #ffffff; filter: drop-shadow(0 0 8px #ffffff); } /* White */
      100% { background: #00ffff; filter: drop-shadow(0 0 8px #00ffff); } /* Back to Cyan */
    }
  </style>
      <script type="text/javascript" src="https://cdn.emailjs.com/dist/email.min.js"></script>
</head>
<body>
  <div class="spaceship-container"></div>

  <!-- Glowing orbs / planets -->
  <div class="orb orb1"></div>
  <div class="orb orb2"></div>
  <div class="orb orb3"></div>
  <div class="orb orb-saturn">
    <div class="ring"></div>
  </div>
  <div class="heart heart-left">‚ù§Ô∏è U</div>
  <div class="heart heart-right">K ‚ù§Ô∏è</div>
  

  <div class="romantic-hearts"></div>

  <div class="question-section" id="question-section">
    <div id="message-1" class="message">Hey there, Pookie! ‚ú®</div>
    <div id="message-2" class="message">Commencing intergalactic transmission... üöÄ</div>
    <form>
        <p>Share your preferred method to rendezvous among the stars.</p>
        <label><input type="radio" name="contact" value="Phone number" required> Stellar Call (Phone Number)</label>
        <label><input type="radio" name="contact" value="Snapchat ID"> Cosmic Chat (Snapchat)</label>
        <label><input type="radio" name="contact" value="Instagram ID"> Galactic Glance (Instagram)</label>
        <div id="input-container">
          <input type="text" id="contact-detail" placeholder="Enter your transmission details">
        </div>
        <button type="button" id="submit-button" onclick="submitForm()">Transmit</button>
      </form>
  </div>
  <div id="success-message" style="display: none; text-align: center; margin-top: 20px;">
    <h3 style="color: #00ff80; font-size: 1.5em; margin-bottom: 10px;">Transmission Successful! ‚úÖ</h3>
    <p style="color: #00eaff; font-size: 1em;">Your contact information has been sent among the stars. ‚ú®</p>
</div>

  <script>
    // Function to show elements with delays
    function revealElements() {
      const message1 = document.getElementById('message-1');
      message1.classList.add('visible');  // Show the first message (Hey there, Pookie)

      setTimeout(() => {
        const message2 = document.getElementById('message-2');
        message2.classList.add('visible');  // Show the second message (Commencing intergalactic transmission)
      }, 2000);  // Delay for the second message (2 seconds)

      setTimeout(() => {
        const inputContainer = document.getElementById('input-container');
        inputContainer.style.display = 'block';  // Show the input container (contact details)
      }, 4000);  // Delay for the input container (4 seconds)

      setTimeout(() => {
        const submitButton = document.getElementById('submit-button');
        submitButton.classList.add('visible');  // Show the submit button
      }, 6000);  // Delay for the submit button (6 seconds)
    }

  
    // Reveal input when a radio button is selected.
    document.querySelectorAll('input[type=radio]').forEach(radio => {
      radio.addEventListener('change', () => {
        document.getElementById('input-container').style.display = 'block';
      });
    });

    // Helper: Quadratic Bezier point calculator.
    function quadraticBezier(P0, CP, P1, t) {
      return {
        x: Math.pow(1-t, 2)*P0.x + 2*(1-t)*t*CP.x + Math.pow(t,2)*P1.x,
        y: Math.pow(1-t, 2)*P0.y + 2*(1-t)*t*CP.y + Math.pow(t,2)*P1.y
      };
    }
    
    // Animate the transmission star along the heart-shaped path.
    function animateStarAlongHeartPath(start, mid, cp_left, cp_right, end, duration, star) {
      const startTime = performance.now();
      function step(now) {
        let t = (now - startTime) / duration;
        if(t > 1) t = 1;
        let pos;
        if(t <= 0.5) {
          // First half (left segment): map t from 0 to 0.5 to t' in [0,1]
          const tPrime = t / 0.5;
          pos = quadraticBezier(start, cp_left, mid, tPrime);
        } else {
          // Second half (right segment)
          const tPrime = (t - 0.5) / 0.5;
          pos = quadraticBezier(mid, cp_right, end, tPrime);
        }
        star.style.left = pos.x + 'px';
        star.style.top = pos.y + 'px';
        if(t < 1) {
          requestAnimationFrame(step);
        }
      }
      requestAnimationFrame(step);
    }
    
    emailjs.init("UUxUCWkFJBKLGkOPf"); // Replace with your public API key

    function submitForm() {
    console.log("submitForm() function called!");
    const contactType = document.querySelector('input[name="contact"]:checked');
    const contactDetail = document.getElementById('contact-detail').value;

    console.log("Contact Type:", contactType);
    console.log("Contact Detail:", contactDetail);

    if ( !contactDetail) {
        console.log("Validation failed: Please select a contact method and enter details.");
        alert('Please select a contact method and enter the details!');
        return;
    }

    console.log("Validation passed. Proceeding with EmailJS.");
    console.log("Contact Type Value:", contactType.value);

    console.log("About to call emailjs.send..."); // ADD THIS LOG - Right before emailjs.send

    emailjs.send('service_lnaepwf', 'template_5w50wk2', {
        contact_type: contactType.value,
        contact_detail: contactDetail
    })
    .then(response => {
        console.log("EmailJS .then() block entered"); // Keep this log
        console.log("EmailJS Success:", response); // Keep this log
        console.log("About to call transmitAnimation() from .then()"); // ADD THIS LOG - Before transmitAnimation()
        transmitAnimation();
        console.log("transmitAnimation() called from .then()"); // ADD THIS LOG - After transmitAnimation()
        console.log('Success (inside .then()):', response);
    })
    .catch(error => {
        console.log("EmailJS .catch() block entered"); // Keep this log
        console.error("EmailJS Error:", error);
        console.error('Error (inside .catch()):', error);
        alert('Oops! Something went wrong. Please try again.');
    });

    console.log("Function submitForm() execution continuing after emailjs.send..."); // ADD THIS LOG - After emailjs.send
}

    
    // Transmission animation:
    // Launch a glowing star from the edge of the left orb ("U") to the edge of the right orb ("K"),
    // and create a dotted, glowing trail that follows a heart-shaped path.
    function transmitAnimation() {
        console.log("transmitAnimation() function called! (Function entry)");
      const leftOrb = document.querySelector('.heart-left');
      const rightOrb = document.querySelector('.heart-right');
      const leftRect = leftOrb.getBoundingClientRect();
      const rightRect = rightOrb.getBoundingClientRect();
      
      // Calculate centers.
      const leftCenter = { x: leftRect.left + leftRect.width/2, y: leftRect.top + leftRect.height/2 };
      const rightCenter = { x: rightRect.left + rightRect.width/2, y: rightRect.top + rightRect.height/2 };
      
      // Compute unit vector from left to right.
      const dx = rightCenter.x - leftCenter.x;
      const dy = rightCenter.y - leftCenter.y;
      const distance = Math.sqrt(dx*dx + dy*dy);
      const ux = dx / distance;
      const uy = dy / distance;
      
      // Define start and end points on the edges of the orbs.
      const start = { x: leftCenter.x + (leftRect.width/2) * ux,
                      y: leftCenter.y + (leftRect.height/2) * uy };
      const end = { x: rightCenter.x - (rightRect.width/2) * ux,
                    y: rightCenter.y - (rightRect.height/2) * uy };
      
      // Define a "bottom" point for the heart shape.
      const midX = (start.x + end.x) / 2;
      const bottomY = start.y + 80; // offset downward; adjust as needed
      const mid = { x: midX, y: bottomY };
      
      // Control points for quadratic curves (to form a heart shape)
      const cp_left = { x: start.x - 50, y: (start.y + bottomY) / 2 };
      const cp_right = { x: end.x + 50, y: (end.y + bottomY) / 2 };
      
      // --- Create dotted, glowing trail along the heart-shaped path ---
      const totalDots = 300;
      // We'll sample 8 points on the left segment (from start to mid) and 7 on the right.
      const dots = [];
      for (let i = 0; i < 8; i++) {
        const t = i / 7; // t in [0,1]
        const point = quadraticBezier(start, cp_left, mid, t);
        dots.push(point);
      }
      for (let i = 1; i < 8; i++) { // avoid duplicating the mid point
        const t = i / 7;
        const point = quadraticBezier(mid, cp_right, end, t);
        dots.push(point);
      }
      // Create and place trail dots.
      dots.forEach((pt, index) => {
        const dot = document.createElement('div');
        dot.classList.add('trail-dot');
        dot.style.left = pt.x + 'px';
        dot.style.top = pt.y + 'px';

        // --- VERY Drastic Size Variation for Testing ---
        const size = Math.random() * 10 + 2; // Size between 2px and 12px - very wide range
        dot.style.width = size + 'px';
        dot.style.height = size + 'px';
        dot.style.opacity = Math.random() * 0.5 + 0.5;
        // Stagger the animation delay for a sequential glowing effect.
        dot.style.animationDelay = (index * 0.1) + 's';
        document.body.appendChild(dot);
      });
      
      // Create transmission star element.
      const star = document.createElement('div');
      star.classList.add('transmission-star');
      star.innerHTML = '‚≠ê';
      star.style.left = start.x + 'px';
      star.style.top = start.y + 'px';
      document.body.appendChild(star);
      
      // Animate the star along the heart-shaped path over 2000ms.
      animateStarAlongHeartPath(start, mid, cp_left, cp_right, end, 2000, star);
      
      setTimeout(() => {
       // star.remove();
      //  document.querySelectorAll('.trail-dot').forEach(dot => dot.remove());
        console.log("Inside setTimeout in transmitAnimation - before showing success message");

        // --- Hide the question-section ---
        const questionSectionDiv = document.getElementById('question-section');
        questionSectionDiv.style.display = 'none'; // Hide the question section

        console.log("question-section hidden.");

        // --- Show the Success Message Element ---
        const successMessageDiv = document.getElementById('success-message');
        successMessageDiv.style.display = 'block'; // Make the success message visible

        console.log("Success message displayed.");

        // --- Hide the Success Message after a delay (e.g., 3 seconds) ---
        setTimeout(() => {
            successMessageDiv.style.display = 'none'; // Hide the success message again
            console.log("Success message hidden after delay.");
        }, 60000); // Hide after 60 seconds

        console.log("Inside setTimeout in transmitAnimation - after showing success message and setting hide timeout");
        // alert("Successful transmission!"); // Removed alert
    }, 2050);

    console.log("transmitAnimation() function ending (Function exit)");
}
    
    // Generate floating romantic hearts.
    function createRomanticHearts() {
      const container = document.querySelector('.romantic-hearts');
      for (let i = 0; i < 5; i++) {
        let heart = document.createElement('span');
        heart.innerHTML = '‚ù§Ô∏è';
        heart.style.left = Math.random() * 100 + 'vw';
        heart.style.top = Math.random() * 100 + 'vh';
        heart.style.fontSize = (Math.random() * 1 + 1) + 'em';
        heart.style.animationDuration = Math.random() * 3 + 4 + 's';
        container.appendChild(heart);
        setTimeout(() => heart.remove(), 6000);
      }
    }
    setInterval(createRomanticHearts, 1500);

    // Generate drifting floating hearts.
    function createSpaceshipHeart() {
      let heart = document.createElement('span');
      heart.classList.add('spaceship-star');
      heart.innerHTML = '‚ù§Ô∏è';
      heart.style.left = Math.random() * 100 + 'vw';
      heart.style.top = Math.random() * 100 + 'vh';
      let angle = Math.random() * 360;
      let distance = Math.random() * 20 + 10;
      let dx = distance * Math.cos(angle * Math.PI / 180);
      let dy = distance * Math.sin(angle * Math.PI / 180);
      heart.style.setProperty('--dx', dx + 'vw');
      heart.style.setProperty('--dy', dy + 'vh');
      document.querySelector('.spaceship-container').appendChild(heart);
      setTimeout(() => heart.remove(), 4000);
    }
    setInterval(createSpaceshipHeart, 500);
    window.addEventListener('DOMContentLoaded', () => {
  revealElements();
});
  </script>
</body>
</html>
